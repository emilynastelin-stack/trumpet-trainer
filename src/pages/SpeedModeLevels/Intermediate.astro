---
import Layout from '../../layouts/Layout.astro';

const serverImages = [
  'C1.png',
  'D1.png',
  'E1.png',
  'F1.png',
  'G1.png',
  'A1.png',
  'B1.png',
  'G0.png',
  'A0.png',
  'B0.png',
  'C2.png',
  'D2.png',
  'E2.png',
  'F2.png',
  'G2.png'
  , 'Gsharp0.png', 'Asharp0.png', 'Csharp1.png', 'Dsharp1.png', 'Fsharp1.png', 'Gsharp1.png', 'Asharp1.png', 'Csharp2.png', 'Dsharp2.png', 'Fsharp2.png', 'Gsharp2.png'
  , 'Gflat0.png', 'Aflat0.png', 'Bflat0.png', 'Dflat1.png', 'Eflat1.png', 'Gflat1.png', 'Aflat1.png', 'Bflat1.png', 'Dflat2.png', 'Eflat2.png', 'Gflat2.png'
];
const initialImage = serverImages[Math.floor(Math.random() * serverImages.length)];
---

<Layout>
  <main style="display:flex; flex-direction:column; align-items:center; justify-content:center; min-height:100vh; padding:2rem; box-sizing:border-box; background: #1f1c2c; color: white; position:relative;">
    
    <!-- Fingering Image -->
    <img
      id="fingeringImg"
      class="fingering-img"
      src={`/assets/images/${initialImage}`}
      data-images={JSON.stringify(serverImages)}
      data-initial={initialImage}
      alt="Random Fingering"
      tabindex="0"
      role="img"
      aria-label="Random fingering image"
      style="max-width:300px; width:80%; border-radius:1rem; box-shadow:0 8px 20px rgba(0,0,0,0.5); margin-bottom:2rem; outline:none;"
    />

    <!-- Streak display -->
    <div id="streak" style="position: absolute; top: 20px; right: 20px; background: rgba(0,0,0,0.36); color: #fff; padding: 0.5rem 0.75rem; border-radius: 10px; font-weight:700; box-shadow: 0 6px 18px rgba(0,0,0,0.6);">
      Streak: <span id="streak-value">0</span> 
      <small style="opacity:0.8; margin-left:6px;">Best: <span id="best-value">0</span></small>
    </div>

    <!-- Countdown (speed test) -->
    <div id="speed-countdown" style="width:320px; height:10px; margin-top:8px; margin-bottom:8px;">
      <div id="speed-fill" style="width:100%; height:100%; border-radius:999px; background:linear-gradient(90deg,#34d399,#f59e0b); box-shadow:0 6px 18px rgba(0,0,0,0.35) inset;"></div>
    </div>
    <div id="speed-ms-display" style="color:rgba(255,255,255,0.85); margin-top:6px; font-weight:700; font-size:13px;">â€” ms</div>

    <!-- Gamepad -->
    <div id="gamepad" style="display:flex; flex-direction:column; align-items:center; gap:0.6rem; margin-top:1.25rem;">
      <div style="display:flex; gap:0.6rem;">
       <button data-button="1" class="gp-btn" style="width:96px; height:96px; border-radius:16px;">1</button>
       <button data-button="2" class="gp-btn" style="width:96px; height:96px; border-radius:16px;">2</button>
       <button data-button="3" class="gp-btn" style="width:96px; height:96px; border-radius:16px;">3</button>
      </div>
      <button data-button="0" id="gp-zero" class="gp-btn" style="width:320px; height:80px; border-radius:40px;">0</button>
    </div>

    <!-- Test / Stop controls -->
    <div style="margin-top:0.75rem; display:flex; gap:0.6rem;">
      <button id="stop-btn" style="padding:10px 14px; border-radius:12px; background:#ef4444; color:#fff; font-weight:700; border:none; cursor:pointer;">Stop</button>
    </div>

    <!-- Start overlay -->
    <div id="start-overlay" style="position:fixed; inset:0; display:flex; align-items:center; justify-content:center; background:rgba(9,9,12,0.82); z-index:1200;">
      <div style="text-align:center;">
          <div style="display:flex; flex-direction:column; gap:10px; justify-content:center; align-items:center;">
            <button class="diff-btn diff-easy" data-ms="3000">Easy</button>
            <button class="diff-btn diff-medium diff-active" data-ms="2000">Medium</button>
            <button class="diff-btn diff-hard" data-ms="1000">Hard</button>
            <button class="diff-btn diff-accelerando" data-mode="accelerando" data-start-ms="3000" data-end-ms="500">Accelerando</button>
            <button id="overlay-home" style="margin-top:6px; padding:8px 10px; border-radius:10px; background:#111827; color:#fff; border:none; font-weight:700;">Home</button>
          </div>
          <div style="margin-top:12px;">
            <div id="countdown-display" style="font-size:48px; font-weight:800; color:white; opacity:0.0; transition:opacity 120ms linear;">3</div>
            <div id="countdown-dots" class="countdown-dots" aria-hidden="true" style="margin-top:10px; display:flex; gap:8px; justify-content:center;">
              <span class="cd-dot" data-idx="1" style="width:10px;height:10px;border-radius:50%;background:rgba(255,255,255,0.18);"></span>
              <span class="cd-dot" data-idx="2" style="width:10px;height:10px;border-radius:50%;background:rgba(255,255,255,0.18);"></span>
              <span class="cd-dot" data-idx="3" style="width:10px;height:10px;border-radius:50%;background:rgba(255,255,255,0.18);"></span>
            </div>
          </div>
      </div>
    </div>

    <!-- Results overlay (hidden by default) -->
    <div id="results-overlay" style="position:fixed; inset:0; display:none; align-items:center; justify-content:center; background:rgba(7,7,10,0.9); z-index:1300; color:white;">
      <div style="text-align:center; max-width:420px; padding:24px; border-radius:12px; background:linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.02)); box-shadow:0 18px 48px rgba(0,0,0,0.6);">
        <h2 style="margin:0 0 6px 0; font-size:26px;">Results</h2>
        <div style="font-size:18px; opacity:0.9; margin-bottom:12px;">You completed <span id="res-cards">0</span> cards</div>
        <div style="display:flex; gap:12px; justify-content:center; margin-bottom:14px;">
          <div style="text-align:center;"><div style="font-weight:800; font-size:22px;"> <span id="res-correct">0</span></div><div style="opacity:0.8;">Correct</div></div>
          <div style="text-align:center;"><div style="font-weight:800; font-size:22px;"> <span id="res-wrong">0</span></div><div style="opacity:0.8;">Wrong</div></div>
        </div>
        <div style="display:flex; gap:8px; justify-content:center;"><button id="res-restart" style="padding:10px 14px; border-radius:10px; background:#10b981; color:white; border:none; font-weight:700;">Restart</button><button id="res-close" style="padding:10px 14px; border-radius:10px; background:#374151; color:white; border:none; font-weight:700;">Close</button></div>
      </div>
    </div>

    <style>
      :root{
        --anim-pop: 680ms;
        --anim-correct: 700ms;
        --anim-confetti: 1000ms;
        --anim-shake: 200ms; /* faster shake */
        --anim-wrong-glow: 360ms;
        --anim-safety: 420ms;
        --reveal-duration: 2500ms;
        --press-duration: 120ms;
      }
    /* Image animations */
    /* Temporarily disable base transition so shake keyframes are fully visible while testing */
    .fingering-img { /* transition: transform 320ms ease, opacity 320ms ease, filter 320ms ease; */ cursor:pointer; }
  .fingering-anim { animation: popRotateHue var(--anim-pop) cubic-bezier(.2,.9,.3,1); box-shadow: 0 30px 80px rgba(14,165,164,0.35) !important; border-radius:1rem; transform-origin:50% 60%; }
    @keyframes popRotateHue { 0%{transform:scale(0.88) rotate(-12deg);opacity:0;}50%{transform:scale(1.14) rotate(8deg);opacity:1;}100%{transform:scale(1) rotate(0deg);opacity:1;} }

      /* Correct combo: pop + hue flash + confetti */
  .correct-anim { animation: correctPop var(--anim-correct) ease-out forwards; transform-origin:50% 60%; }
      @keyframes correctPop { 0%{transform:scale(1) rotate(0deg);filter:hue-rotate(0deg) saturate(1);} 50%{transform:scale(1.18) rotate(5deg);filter:hue-rotate(90deg) saturate(1.4);}100%{transform:scale(1) rotate(0deg);filter:hue-rotate(0deg) saturate(1);} }

      /* Confetti */
  .confetti { position:absolute; bottom:40%; width:6px; height:6px; border-radius:50%; pointer-events:none; transform:translateY(0) scale(1); animation: confettiRise var(--anim-confetti) ease-out forwards; opacity:0.9; }
      @keyframes confettiRise { 0%{transform:translateY(0) rotate(0deg) scale(0.8); opacity:1;} 50%{transform:translateY(-80px) rotate(180deg) scale(1.1); opacity:0.9;} 100%{transform:translateY(-140px) rotate(360deg) scale(1); opacity:0;} }

      /* Shake for wrong combo: fast left-right oscillation (no hinge) */
      @keyframes shakeX {
        0% { transform: translateX(0); }
        10% { transform: translateX(-25px); }
        20% { transform: translateX(25px); }
        30% { transform: translateX(-20px); }
        40% { transform: translateX(20px); }
        50% { transform: translateX(-15px); }
        60% { transform: translateX(15px); }
        70% { transform: translateX(-10px); }
        80% { transform: translateX(10px); }
        90% { transform: translateX(-5px); }
        100% { transform: translateX(0); }
      }
      /* stronger, more visible shake for testing */
  .shake { animation: shakeX 400ms ease-in-out 1 !important; transition: none !important; will-change: transform; }
  /* ensure transition doesn't smooth out the keyframe and hint the GPU to optimize */
  img.fingering-img.shake { /* transition: none !important; */ will-change: transform; }

      /* Gamepad */
        .gp-btn {
          background:#0ea5a4; color:white; border:none; font-weight:800; font-size:1.35rem;
          display:inline-flex; align-items:center; justify-content:center; cursor:pointer;
          box-shadow: 0 8px 22px rgba(2,6,23,0.35);
          transition: transform 160ms ease, box-shadow 160ms ease;
          touch-action: manipulation;
          -webkit-tap-highlight-color: rgba(0,0,0,0);
        }
        .gp-btn:active { transform: translateY(3px) scale(0.985); box-shadow: 0 6px 16px rgba(2,6,23,0.28); }
        #gp-zero:active { transform: translateY(3px) scale(0.992); }

        /* immediate pressed state (for quick tactile feedback) */
        .gp-pressed { transform: translateY(2px) scale(0.975); box-shadow: 0 4px 10px rgba(2,6,23,0.25) !important; }

  /* button flash for wrong attempts */
  .gp-wrong { background: linear-gradient(90deg,#ef4444,#f97316) !important; color: white !important; transform: scale(1.02) !important; box-shadow: 0 10px 36px rgba(239,68,68,0.65) !important; }

        /* red glow for wrong answer (stronger, higher specificity) */
        @keyframes wrongGlow {
          0% { box-shadow: 0 0 0 rgba(239,68,68,0); filter: saturate(1); }
          40% { box-shadow: 0 0 36px rgba(239,68,68,1); filter: saturate(1.25); }
          100% { box-shadow: 0 0 0 rgba(239,68,68,0); filter: saturate(1); }
        }
    /* align duration with shake so they occur together */
  /* Run both the glow and the shake together so one doesn't override the other */
  img.fingering-img.wrong-glow { animation: wrongGlow var(--anim-wrong-glow) ease forwards, shakeX var(--anim-shake) ease-in-out 1; box-shadow: 0 0 36px rgba(239,68,68,0.95) !important; border: 3px solid rgba(239,68,68,0.65) !important; }

        /* responsive: scale down on very small screens */
        @media (max-width:420px) {
          .gp-btn { font-size:1.05rem; }
          #gp-zero { width: 260px !important; height: 68px !important; }
          #gamepad > div button { width:80px !important; height:80px !important; }
        }
      .gp-btn:active,#gp-zero:active{transform:translateY(2px) scale(0.98);}
      .gp-hint { box-shadow:0 10px 30px rgba(250,204,21,0.9); transform:scale(1.08); background:linear-gradient(90deg,#f59e0b,#fbbf24); color:#111827 !important; }

  /* Speed countdown bar */
  #speed-countdown { width:320px; height:10px; background: rgba(255,255,255,0.06); border-radius:999px; overflow:hidden; }
  #speed-fill { width:100%; height:100%; transition: width 2000ms linear; }
  #speed-ms-display { text-align:center; }
  /* Start overlay styles (small mobile tweak) */
  @media (max-width:420px) { #start-btn{ font-size:1.05rem; padding:12px 18px; } #speed-countdown{ width:260px; } }
  /* difficulty button active */
  /* Base diff button styling (vertical layout) */
  #start-overlay .diff-btn { padding:14px 20px; border-radius:12px; min-width:160px; border:none; cursor:pointer; color:#fff; font-weight:800; font-size:1.05rem; }
  #overlay-home { padding:12px 18px; min-width:140px; border-radius:10px; }
  #start-overlay .diff-easy { background: linear-gradient(90deg,#34d399,#10b981); }
  #start-overlay .diff-medium { background: linear-gradient(90deg,#f59e0b,#f97316); }
  #start-overlay .diff-hard { background: linear-gradient(90deg,#ef4444,#dc2626); }
  #start-overlay .diff-accelerando { background: linear-gradient(90deg,#8b5cf6,#a78bfa); }
  /* Active state for selected difficulty */
  #start-overlay .diff-btn.diff-active { box-shadow: 0 12px 36px rgba(0,0,0,0.28); transform: scale(1.06); outline: 3px solid rgba(255,255,255,0.06); }
  #countdown-display.show { opacity:1.0; }
  /* Countdown dot styles */
  .countdown-dots { transform-origin:center; }
  .cd-dot { transition: transform 260ms cubic-bezier(.2,.9,.3,1), background 220ms ease, opacity 220ms ease; }
  .cd-dot.active { background: linear-gradient(90deg,#f59e0b,#f97316); transform: scale(1.6); opacity:1; box-shadow:0 10px 30px rgba(250,204,21,0.12); }

      /* Streak pulse */
      @keyframes streakPulse { 0%{transform:scale(1);}40%{transform:scale(1.08);box-shadow:0 18px 48px rgba(14,165,164,0.28);}100%{transform:scale(1);} }
      .streak-pulse { animation: streakPulse 720ms cubic-bezier(.2,.9,.3,1); }

      /* Bubbles (optional) */
      .bubble { position:absolute; bottom:40%; border-radius:50%; pointer-events:none; transform:translateY(0) scale(0.6); animation:bubbleRise 900ms cubic-bezier(.2,.9,.3,1) forwards; opacity:0.95; mix-blend-mode:screen; box-shadow:0 10px 40px rgba(14,165,164,0.35); }
      @keyframes bubbleRise {0%{transform:translateY(0) scale(0.6);opacity:0.95;}60%{transform:translateY(-90px) scale(1.05);opacity:0.9;}100%{transform:translateY(-140px) scale(1.25);opacity:0;}}
    </style>
  </main>

  <script>
    // @ts-nocheck
    (function(){
      /** @type {HTMLImageElement | null} */
      const img = /** @type {HTMLImageElement | null} */ (document.getElementById('fingeringImg'));
      if(!img) return;

      // Notes with combos and frequency weights. We'll build a weighted draw pile below.
      /** @type {{name:string,combo:string[],freq:number}[]} */
       const notes = [
        { name: "G0.png", combo: ["1","3"], freq: 1 },
        { name: "A0.png", combo: ["1","2"], freq: 1 },
        { name: "B0.png", combo: ["2"], freq: 1 },
        { name: "C1.png", combo: ["0"], freq: 1 },
        { name: "D1.png", combo: ["1","3"], freq: 1 },
        { name: "E1.png", combo: ["1","2"], freq: 1 },
        { name: "F1.png", combo: ["1"], freq: 1 },
        { name: "G1.png", combo: ["0"], freq: 1 },
        { name: "A1.png", combo: ["1","2"], freq: 1 },
        { name: "B1.png", combo: ["2"], freq: 1 },
        { name: "C2.png", combo: ["0"], freq: 1 },
        { name: "D2.png", combo: ["1"], freq: 1 },
        { name: "E2.png", combo: ["0"], freq: 1 },
        { name: "F2.png", combo: ["1"], freq: 1 },
        { name: "G2.png", combo: ["0"], freq: 1 },
        { name: "Fsharp0.png", combo: ["1","2","3"], freq: 3 },
        { name: "Gsharp0.png", combo: ["2","3"], freq: 3 },
        { name: "Asharp0.png", combo: ["1"], freq: 3 },
        { name: "Csharp1.png", combo: ["1","2","3"], freq: 1 },
        { name: "Dsharp1.png", combo: ["2","3"], freq: 2 },
        { name: "Fsharp1.png", combo: ["2"], freq: 1 },
        { name: "Gsharp1.png", combo: ["2","3"], freq: 2 },
        { name: "Asharp1.png", combo: ["1"], freq: 2 },
        { name: "Csharp2.png", combo: ["1","2"], freq: 2 },
        { name: "Dsharp2.png", combo: ["2"], freq: 3 },
        { name: "Fsharp2.png", combo: ["2"], freq: 2 },
        { name: "Gsharp2.png", combo: ["2","3"], freq: 3 },
        { name: "Gflat0.png", combo: ["1","2","3"], freq: 3 },
        { name: "Aflat0.png", combo: ["2","3"], freq: 2 },
        { name: "Bflat0.png", combo: ["1"], freq: 1 },
        { name: "Dflat1.png", combo: ["1","2","3"], freq: 2 },
        { name: "Eflat1.png", combo: ["2","3"], freq: 1 },
        { name: "Gflat1.png", combo: ["2"], freq: 3 },
        { name: "Aflat1.png", combo: ["2","3"], freq: 2 },
        { name: "Bflat1.png", combo: ["1"], freq: 1 },
        { name: "Dflat2.png", combo: ["1","2"], freq: 2 },
        { name: "Eflat2.png", combo: ["2"], freq: 1 },
        { name: "Gflat2.png", combo: ["2"], freq: 3 }
      ];


      // Build mapping name -> combo for quick lookup
      /** @type {{[key:string]: string[]}} */
      const answerKey = {};
      notes.forEach(n=>{ answerKey[n.name] = n.combo.slice(); });

      // Image filename list (unique names)
      /** @type {string[]} */
      let images = notes.map(n=>n.name);
      /** @type {number} */
      let currentIndex = images.indexOf(String(img.dataset.initial || images[0] || '')) || 0;

      // Build a weighted name array for the draw pile (more copies = more common)
      /** @type {string[]} */
      const weightedNames = [];
      notes.forEach(note => {
        // weight: 1 = most frequent -> 3 copies, 3 = least -> 1 copy
        const weight = Math.max(1, 4 - (note.freq || 1));
        for (let i = 0; i < weight; i++) weightedNames.push(note.name);
      });

  /** @type {Set<string>} */
  const activeKeys = new Set();
  /** @type {{key:string,time:number}[]} */
  const recentPresses = [];
  // make detection snappier for quicker UX; small but allows multi-key simultaneity
  const TOUCH_WINDOW = 120;
  // Read CSS timing variables (return milliseconds)
  function cssMs(varName, fallbackMs){
    try{
      const v = getComputedStyle(document.documentElement).getPropertyValue(varName).trim() || '';
      if(!v) return fallbackMs;
      if(v.endsWith('ms')) return parseFloat(v.replace('ms',''));
      if(v.endsWith('s')) return parseFloat(v.replace('s',''))*1000;
      return fallbackMs;
    }catch(e){return fallbackMs;}
  }
  const ANIM_POP = cssMs('--anim-pop', 680);
  const ANIM_CORRECT = cssMs('--anim-correct', 700);
  const ANIM_CONFETTI = cssMs('--anim-confetti', 1000);
  const ANIM_SHAKE = cssMs('--anim-shake', 360);
  const ANIM_WRONG_GLOW = cssMs('--anim-wrong-glow', 360);
  const ANIM_SAFETY = cssMs('--anim-safety', 420);
  const REVEAL_DURATION = cssMs('--reveal-duration', 2500);
  const PRESS_DURATION = cssMs('--press-duration', 120);
  // Speed test: user must answer within speedLimitMs or it's considered wrong
  let speedLimitMs = parseInt(localStorage.getItem('speed-limit-ms')||'2000',10) || 2000;
  let speedMode = localStorage.getItem('speed-mode') || 'fixed'; // 'fixed' or 'ramp'
  let speedTimer = null;
  let speedFill = null; // element for the animated fill
  let speedRunning = false;
  let countdownTimer = null;
  let countdownValue = 3;
  /** @type {number|null} */
  let wrongTimeout = null;
    /** @type {{[k:string]:number}} */
    const wrongCounts = {};
  // test-run counters and limits
  let totalCards = 20; // number of cards per test run
  let cardsSeen = 0; // how many cards have been shown in this run
  let correctCount = 0; // how many correct answers this run
  let wrongCountTotal = 0; // how many wrong answers this run
  /** @type {number|null} */
  let revealTimeout = null;
  // track when the last correct animation started/ended to avoid overlapping wrong visuals
  let lastCorrectAt = 0;
      let streak = parseInt(localStorage.getItem('fingering-streak')||'0',10)||0;
      let best = parseInt(localStorage.getItem('fingering-best')||'0',10)||0;
      const streakEl = document.getElementById('streak-value');
      const bestEl = document.getElementById('best-value');
    if(streakEl) streakEl.textContent = String(streak);
    if(bestEl) bestEl.textContent = String(best);

      /** @param {number} idx */
  function setImage(idx){
        // clear any visible hints when switching cards
        clearHints();
        const filename = images[idx];
        const url = `/assets/images/${encodeURIComponent(filename)}`;
        const pre = new Image();
        pre.src = url;
        pre.onload = ()=>{ if(img) img.src = url; }

        // increment cards shown for this run (only when test is running)
        if(speedRunning){
          cardsSeen = (cardsSeen || 0) + 1;
        }

        // start/reset speed countdown
        // compute effective speedLimitMs in ramp mode
        try{
          if(speedMode === 'ramp'){
            // eased interpolation for a more obvious accelerando effect
            const startMs = Number(localStorage.getItem('speed-ramp-start')||'3000');
            const endMs = Number(localStorage.getItem('speed-ramp-end')||'500');
            const progress = Math.min(1, (cardsSeen-1) / Math.max(1, totalCards-1));
            // ease-in (quadratic) so acceleration becomes more pronounced later in the run
            const eased = Math.pow(progress, 2);
            speedLimitMs = Math.round(startMs + (endMs - startMs) * eased);
            // update ms display and tint the fill based on eased progress
            try{
              const msDisp = document.getElementById('speed-ms-display');
              if(msDisp) msDisp.textContent = `${speedLimitMs} ms`;
            }catch(e){}
            try{
              // hue from green -> purple (140 -> 280)
              const hue = Math.round(140 + eased * 140);
              if(speedFill) speedFill.style.background = `linear-gradient(90deg, hsl(${hue},75%,55%), hsl(${(hue+18)%360},75%,45%))`;
            }catch(e){}
          } else {
            // ensure speedLimitMs from persisted fixed choice
            speedLimitMs = Number(localStorage.getItem('speed-limit-ms')||String(speedLimitMs));
            try{ const msDisp = document.getElementById('speed-ms-display'); if(msDisp) msDisp.textContent = `${speedLimitMs} ms`; }catch(e){}
            try{ if(speedFill) speedFill.style.background = 'linear-gradient(90deg,#34d399,#f59e0b)'; }catch(e){}
          }
        }catch(e){}
        try{
          speedFill = document.getElementById('speed-fill');
          if(speedFill){
            // reset instantly then animate to 0 over SPEED_LIMIT_MS
            speedFill.style.transition = 'none';
            speedFill.style.width = '100%';
            // flush
            void speedFill.offsetWidth;
            speedFill.style.transition = `width ${speedLimitMs}ms linear`;
            // animate to 0
            setTimeout(()=>{ if(speedFill) speedFill.style.width = '0%'; },10);
          }
        }catch(e){}

  if(!speedRunning) return; // don't start timers until test started
  if(speedTimer) { clearTimeout(speedTimer); speedTimer = null; }
        speedTimer = /** @type {number} */ (setTimeout(()=>{
          // if timer fires, treat as wrong then advance to next card
          const pressedBtn = /** @type {HTMLElement|null} */ (document.querySelector('#gamepad .gp-pressed'));
          triggerWrongVisual(pressedBtn);
          speedTimer = null;
          // small delay so wrong visual is visible before advancing
          setTimeout(()=>{ try{ advanceToNext(); }catch(e){console.error('advanceToNext failed',e);} }, 220);
        }, speedLimitMs));
      }


  function endRunAndShowResults(){
    speedRunning = false;
    if(speedTimer){ clearTimeout(speedTimer); speedTimer = null; }
    if(countdownTimer){ clearInterval(countdownTimer); countdownTimer = null; }
    // populate results
    try{
      const ro = document.getElementById('results-overlay');
      if(ro){
        document.getElementById('res-cards').textContent = String(cardsSeen);
        document.getElementById('res-correct').textContent = String(correctCount);
        document.getElementById('res-wrong').textContent = String(wrongCountTotal);
        ro.style.display = 'flex';
      }
    }catch(e){console.error('show results failed',e);}  }
      function setDifficulty(ms){
        speedLimitMs = Number(ms) || 2000;
        speedMode = 'fixed';
        try{ localStorage.setItem('speed-limit-ms', String(speedLimitMs)); localStorage.setItem('speed-mode', speedMode); }catch(e){}
        // update UI active state (highlight fixed diff buttons, clear ramp)
        try{
          document.querySelectorAll('#start-overlay .diff-btn').forEach(b=>{
            if(b.getAttribute('data-mode')==='ramp') { b.classList.remove('diff-active'); }
            else if(Number(b.getAttribute('data-ms'))===speedLimitMs) b.classList.add('diff-active'); else b.classList.remove('diff-active');
          });
        }catch(e){}
      }

      function setRampMode(startMs, endMs){
        speedMode = 'ramp';
        try{
          localStorage.setItem('speed-mode', speedMode);
          localStorage.setItem('speed-ramp-start', String(startMs));
          localStorage.setItem('speed-ramp-end', String(endMs));
        }catch(e){}
        try{ document.querySelectorAll('#start-overlay .diff-btn').forEach(b=>{ if(b.getAttribute('data-mode')==='ramp') b.classList.add('diff-active'); else b.classList.remove('diff-active'); }); }catch(e){}
      }

      function startSpeedTest(){
        const overlay = document.getElementById('start-overlay');
        if(overlay) overlay.style.display = 'none';
        speedRunning = true;
        // restart countdown for current card
        try{ setImage(currentIndex); }catch(e){}
      }

      function stopSpeedTest(){
        speedRunning = false;
        if(speedTimer){ clearTimeout(speedTimer); speedTimer = null; }
        if(countdownTimer){ clearInterval(countdownTimer); countdownTimer = null; }
        try{ const disp = document.getElementById('countdown-display'); if(disp){ disp.classList.remove('show'); disp.textContent = '3'; } }catch(e){}
          try{ const dots = document.querySelectorAll('#countdown-dots .cd-dot'); dots.forEach(d=>d.classList.remove('active')); }catch(e){}
        try{ if(speedFill){ speedFill.style.transition='none'; speedFill.style.width='100%'; } }catch(e){}
        const overlay = document.getElementById('start-overlay');
        if(overlay) overlay.style.display = 'flex';
      }

      function clearHints(){
        try{
          const buttons = document.querySelectorAll('#gamepad [data-button]');
          buttons.forEach(b=>b.classList.remove('gp-hint'));
        }catch(e){}
        if(revealTimeout){ clearTimeout(revealTimeout); revealTimeout = null; }
      }

      // Shuffle helper (Fisher-Yates)
      /** @param {string[]} a */
      function shuffleArray(a){
        const arr = a.slice();
        for(let i=arr.length-1;i>0;i--){
          const j = Math.floor(Math.random()*(i+1));
          [arr[i],arr[j]] = [arr[j],arr[i]];
        }
        return arr;
      }

      // Draw pile: use weightedNames for a weighted random presentation
      let drawPile = shuffleArray(weightedNames.slice());
      // remove the initial image occurrence(s) from the pile to avoid immediate repeat
      (function removeInitialFromPile(){
        const init = String(images[currentIndex] || img.dataset.initial || '');
        // remove all occurrences of the initial filename from the weighted pile
        drawPile = drawPile.filter(n => n !== init);
      })();

      function pickNextRandom(){
        if(drawPile.length === 0) drawPile = shuffleArray(weightedNames.slice());
        // pop from the end for efficiency
        let nextFile = drawPile.pop();
        // avoid immediate repeat if possible
        if(images.length>1 && nextFile === images[currentIndex]){
          // try to take another; push the same file back to front
          drawPile.unshift(nextFile);
          nextFile = drawPile.pop();
        }
        // find the index in the canonical images list (first occurrence)
        const idx = images.indexOf(nextFile);
        if(idx>=0) {
          currentIndex = idx;
          setImage(currentIndex);
        } else {
          // fallback: if not found (shouldn't happen), pick a random index
          currentIndex = Math.floor(Math.random()*images.length);
          setImage(currentIndex);
        }
      }

      function advanceToNext(){ pickNextRandom(); }

      function triggerCorrect(){
        if(!img) return;
        img.classList.remove('correct-anim');
        void img.offsetWidth;
        img.classList.add('correct-anim');
        lastCorrectAt = Date.now();
  for(let i=0;i<5;i++){spawnConfetti(i*40);}
  setTimeout(()=>{ if(img) img.classList.remove('correct-anim'); }, ANIM_CORRECT);
      }

      /** @param {number} [delay] */
      function spawnConfetti(delay=0){
        setTimeout(()=>{
          const conf = document.createElement('div');
          conf.classList.add('confetti');
          conf.style.left = `${Math.random()*80+10}%`;
          conf.style.backgroundColor = `hsl(${Math.random()*360},70%,60%)`;
          if(img && img.parentElement) img.parentElement.appendChild(conf);
    setTimeout(()=>conf.remove(), ANIM_CONFETTI);
        }, delay);
      }

      function triggerShake(){
        // kept for compatibility: use the synchronized triggerWrongVisual for combined visuals
        if(!img) return;
        img.classList.remove('shake');
        void img.offsetWidth;
        img.classList.add('shake');
  setTimeout(()=>{ if(img) img.classList.remove('shake'); }, ANIM_SHAKE + 40);
      }

      // Add wrong visual (red glow + shake) using forced reflow to reliably restart animations
      /** @param {HTMLElement|null} pressedBtn */
      function triggerWrongVisual(pressedBtn){
        // If a correct animation started very recently, skip wrong visuals to avoid overlap
        const now = Date.now();
        if (now - lastCorrectAt < 500) {
          console.log('[fingering] triggerWrongVisual ignored due to recent correct at', lastCorrectAt, 'now', now);
          return;
        }
        const filename = images[currentIndex];
        wrongCounts[filename] = (wrongCounts[filename] || 0) + 1;

  // Remove only the relevant classes and any pressed indicator
  if(img) img.classList.remove('wrong-glow', 'shake');
  if (pressedBtn) pressedBtn.classList.remove('gp-wrong', 'gp-pressed');

        // Force a reflow so the browser recognizes the class removal
        if(img) void img.offsetWidth;

  // Start both wrong glow and shake (red image glow + button flash)
  if(img) img.classList.add('wrong-glow', 'shake');
  if (pressedBtn) pressedBtn.classList.add('gp-wrong');

  console.log('[fingering] triggerWrongVisual applied classes', img?.className);

        // Remove when the animation finishes. Use animationend for reliability,
        // with a forced fallback that sets inline animation to 'none' then removes classes.
        let cleaned = false;
        const cleanup = () => {
          if (cleaned) return;
          cleaned = true;
          if(img) img.classList.remove('wrong-glow', 'shake');
          if (pressedBtn) pressedBtn.classList.remove('gp-wrong', 'gp-pressed');
          if(img) img.removeEventListener('animationend', cleanup);
          // clear inline animation override if any
          try { img.style.animation = ''; } catch (e) {}
          console.log('[fingering] triggerWrongVisual cleaned up classes', img?.className);
        };
        if(img) img.addEventListener('animationend', cleanup, { once: true });

  // Safety fallback: force stop the animation and cleanup after anim safety ms
  const safety = setTimeout(() => {
          if (!cleaned) {
            try { img.style.animation = 'none'; } catch (e) {}
            // force reflow to flush the inline animation change
            if(img) void img.offsetWidth;
            cleanup();
          }
          clearTimeout(safety);
        }, ANIM_SAFETY);

        // reset streak
        streak = 0; try { localStorage.setItem('fingering-streak','0'); } catch(e){}
        if (streakEl) streakEl.textContent = '0';
        if ((wrongCounts[filename]||0) >= 3) { revealComboForCurrent(); wrongCounts[filename] = 0; }
        // record wrong for this run and possibly end the run
        wrongCountTotal = (wrongCountTotal || 0) + 1;
        if (cardsSeen >= totalCards) {
          // show results shortly so animation is visible
          setTimeout(()=>{ endRunAndShowResults(); }, 220);
        }
      }

      function revealComboForCurrent(){
        const currentFilename = String(images[currentIndex]);
        const req = answerKey[currentFilename]||[];
        const buttons = document.querySelectorAll('#gamepad [data-button]');
        buttons.forEach(b=>{if(req.includes(String(b.getAttribute('data-button'))))b.classList.add('gp-hint');});
  if(revealTimeout) clearTimeout(revealTimeout);
  revealTimeout = /** @type {number} */ (setTimeout(()=>{ try{ buttons.forEach(b=>b.classList.remove('gp-hint')); }catch(e){} revealTimeout=null; }, REVEAL_DURATION));
      }

      function checkComboAndAdvance(){
        const filename = String(images[currentIndex]);
        const req = /** @type {string[]} */ (answerKey[filename]||[]);
        console.log('[fingering] checkComboAndAdvance', { currentIndex, filename, req, activeKeys: Array.from(activeKeys), recentPressesLength: recentPresses.length });
        /** @type {Set<string>} */
        const nowKeys = new Set(activeKeys);
        const now = Date.now();
        for(let i=recentPresses.length-1;i>=0;i--){if(now-recentPresses[i].time<=TOUCH_WINDOW) nowKeys.add(recentPresses[i].key); else recentPresses.splice(i,1);}
        const ok = req.every(/** @param {string} k */ (k)=>nowKeys.has(k));
        if(ok){
          triggerCorrect();
          // correct -> cancel speed timer and restore fill instantly
          if(speedTimer){ clearTimeout(speedTimer); speedTimer = null; }
          try{ if(speedFill){ speedFill.style.transition='none'; speedFill.style.width='100%'; } }catch(e){}
          correctCount = (correctCount || 0) + 1;
          // if we've reached the card limit, end the run and show results
          if(cardsSeen >= totalCards){
            setTimeout(()=>{ endRunAndShowResults(); }, 240);
          } else {
            advanceToNext();
          }
          activeKeys.clear();
          recentPresses.length=0;
          if(wrongTimeout){ clearTimeout(wrongTimeout); wrongTimeout = null; }
          wrongCounts[filename]=0;
          streak++; localStorage.setItem('fingering-streak', String(streak));
          if(streakEl) streakEl.textContent=String(streak);
          if(streak>best){best=streak; localStorage.setItem('fingering-best', String(best)); if(bestEl) bestEl.textContent=String(best);}
          const streakNode = document.getElementById('streak');
          if(streakNode) streakNode.classList.add('streak-pulse');
          setTimeout(()=>{ const sn = document.getElementById('streak'); if(sn) sn.classList.remove('streak-pulse'); },900);
          return true;
        }
        return false;
      }

      function handleWrong(){
        console.log('[fingering] handleWrong scheduling wrong visual (touch window)', { currentIndex, filename: images[currentIndex] });
  if(wrongTimeout) clearTimeout(wrongTimeout);
  const filename = String(images[currentIndex]);
        // Delay slightly to allow multi-key grouping, but when fired, run synchronized visual
        const scheduledFilename = String(images[currentIndex]);
        wrongTimeout = /** @type {number} */ (setTimeout(()=>{
          // If the shown image changed since scheduling, skip â€” counts/reveal are per-card
          if (String(images[currentIndex]) !== scheduledFilename) {
            console.log('[fingering] scheduled wrong skipped because card changed', { scheduledFilename, currentShown: images[currentIndex] });
            wrongTimeout = null;
            return;
          }
          // If a correct animation ran since this timeout was scheduled, skip firing the wrong visual.
          const now2 = Date.now();
          if (now2 - lastCorrectAt < 600) {
            console.log('[fingering] skipped scheduled wrong visual because a correct happened', { now: now2, lastCorrectAt });
            wrongTimeout = null;
            return;
          }
          const pressedBtn = /** @type {HTMLElement|null} */ (document.querySelector('#gamepad .gp-pressed'));
          console.log('[fingering] scheduled wrong visual firing', { now: now2, lastCorrectAt, scheduledFilename });
          triggerWrongVisual(pressedBtn);
          wrongTimeout=null;
  }, Math.max(10, TOUCH_WINDOW)));
      }

      // Keyboard
      window.addEventListener('keydown',e=>{
        let k='';
        if(e.code&&e.code.startsWith('Numpad')) k=e.code.replace('Numpad','');
        else if(e.key&&/^[0-9]$/.test(e.key)) k=e.key;
        if(!k||!['0','1','2','3'].includes(k)) return;
        console.log('[fingering] keydown', k);
        activeKeys.add(k);
        const matched = checkComboAndAdvance();
        if(!matched){
          // determine whether immediate wrong feedback is safe (single-key required)
          const filename = images[currentIndex];
          const req = /** @type {string[]} */ (answerKey[filename] || []);
          if(req.length === 1 && !req.includes(k)){
            // immediate strong feedback for single-key mismatches
            triggerWrongVisual(null);
          } else {
            handleWrong();
          }
        }
      });
      window.addEventListener('keyup',e=>{
        let k='';
        if(e.code&&e.code.startsWith('Numpad')) k=e.code.replace('Numpad','');
        else if(e.key&&/^[0-9]$/.test(e.key)) k=e.key;
        if(!k) return;
        activeKeys.delete(k);
      });

      // Gamepad
      document.querySelectorAll('#gamepad [data-button]').forEach(b=>{
        const key=b.getAttribute('data-button');
        if(!key) return;
        const press=()=>{
          console.log('[fingering] gamepad press', key);
          recentPresses.push({key,time:Date.now()});
          const matched = checkComboAndAdvance();
          if(!matched){
            const filename = images[currentIndex];
            const req = /** @type {string[]} */ (answerKey[filename] || []);
            // quick pressed visual
            b.classList.add('gp-pressed');
            setTimeout(()=>b.classList.remove('gp-pressed'), PRESS_DURATION);
            if(req.length === 1 && !req.includes(key)){
              triggerWrongVisual(b);
            } else {
              handleWrong();
            }
          } else {
            // matched: show pressed briefly
            b.classList.add('gp-pressed');
            setTimeout(()=>b.classList.remove('gp-pressed'), PRESS_DURATION);
          }
        }
        b.addEventListener('click',press);
        b.addEventListener('touchstart',e=>{e.preventDefault(); press();},{passive:false});
      });

  // Stop button
  const stopBtn = document.getElementById('stop-btn');
  if (stopBtn) stopBtn.addEventListener('click', ()=>{ try{ stopSpeedTest(); }catch(e){ console.error('stop failed', e);} });

  // Start overlay
  const startBtn = document.getElementById('start-btn');
  if (startBtn) startBtn.addEventListener('click', ()=>{ try{ startSpeedTest(); }catch(e){ console.error('start failed', e);} });

  // difficulty buttons wiring and initialize selected difficulty
  (function initOverlay(){ const overlay = document.getElementById('start-overlay'); if(overlay) overlay.style.display = 'flex';
    try{
      document.querySelectorAll('#start-overlay .diff-btn').forEach(b=>{
        b.addEventListener('click', ()=>{
          // support both legacy 'ramp' and new 'accelerando' data-mode values
          const dm = b.getAttribute('data-mode');
          if(dm==='ramp' || dm==='accelerando' || (b.hasAttribute('data-start-ms') && b.hasAttribute('data-end-ms'))){
            // ramp/accelerando mode
            const startMs = Number(b.getAttribute('data-start-ms')||'3000');
            const endMs = Number(b.getAttribute('data-end-ms')||'500');
            setRampMode(startMs, endMs);
          } else {
            const ms = Number(b.getAttribute('data-ms'))||2000; setDifficulty(ms);
          }
          // start 3-beat countdown then start test
          startCountdownThenRun();
        });
      });
      // apply active class for saved difficulty
      setDifficulty(speedLimitMs);
    }catch(e){ console.error('initOverlay wiring failed', e); }
  })();

  // results overlay buttons
  try{
    const resRestart = document.getElementById('res-restart');
    const resClose = document.getElementById('res-close');
    if(resRestart) resRestart.addEventListener('click', ()=>{
      // reset counters and UI, hide results overlay and restart countdown overlay
      cardsSeen = 0; correctCount = 0; wrongCountTotal = 0;
      const ro = document.getElementById('results-overlay'); if(ro) ro.style.display = 'none';
      const so = document.getElementById('start-overlay'); if(so) so.style.display = 'flex';
    });
    if(resClose) resClose.addEventListener('click', ()=>{
      const ro = document.getElementById('results-overlay'); if(ro) ro.style.display = 'none';
      const so = document.getElementById('start-overlay'); if(so) so.style.display = 'flex';
    });
  }catch(e){ console.error('results wiring failed', e); }

  // overlay Home button
  try{
    const overlayHome = document.getElementById('overlay-home');
    if(overlayHome) overlayHome.addEventListener('click', ()=>{
      try{ stopSpeedTest(); }catch(e){}
      // navigate to site root
      try{ window.location.href = '/'; }catch(e){}
    });
  }catch(e){ console.error('overlay home wiring failed', e); }

  function startCountdownThenRun(){
    // ensure overlay visible and countdown display element
    const display = document.getElementById('countdown-display');
    const overlay = document.getElementById('start-overlay');
    if(!display || !overlay) return;
  // reset run counters for a fresh test
  cardsSeen = 0; correctCount = 0; wrongCountTotal = 0;
  countdownValue = 3;
    display.textContent = String(countdownValue);
    display.classList.add('show');
    // clear any existing
    if(countdownTimer) { clearInterval(countdownTimer); countdownTimer = null; }
    // helper to update dot visuals
    const dots = Array.from(document.querySelectorAll('#countdown-dots .cd-dot'));
    function setDotActive(idx){ dots.forEach(d=>d.classList.toggle('active', Number(d.getAttribute('data-idx'))===idx)); }
    setDotActive(countdownValue);
    countdownTimer = setInterval(()=>{
      countdownValue -= 1;
      if(countdownValue>0){
        display.textContent = String(countdownValue);
        setDotActive(countdownValue);
      }
      else {
        // done
        clearInterval(countdownTimer); countdownTimer = null;
        display.classList.remove('show');
        // clear dots
        setDotActive(0);
        // hide overlay and start
        if(overlay) overlay.style.display = 'none';
        speedRunning = true;
        try{ setImage(currentIndex); }catch(e){}
      }
    }, 700);
  }

      // Click image to randomize
      img.addEventListener('click',()=>{
        let next=Math.floor(Math.random()*images.length);
        while(images.length>1&&next===currentIndex) next=Math.floor(Math.random()*images.length);
        currentIndex=next; setImage(currentIndex);
      });
    })();
  </script>
</Layout>
